export class BaseSuite {
    constructor(name, subject, givens) {
        this.name = name;
        this.subject = subject;
        this.givens = givens;
    }
    test() {
        console.log("\nSuite:", this.name);
        this.givens.forEach((givenThat) => {
            givenThat.test(this.subject);
        });
    }
}
export class BaseGiven {
    constructor(name, whens, thens, feature) {
        this.name = name;
        this.whens = whens;
        this.thens = thens;
        this.feature = feature;
    }
    test(subject) {
        console.log(`\n - ${this.feature} - \n\nGiven: ${this.name}`);
        const store = this.givenThat(subject);
        this.whens.forEach((whenStep) => {
            whenStep.test(store);
        });
        this.thens.forEach((thenStep) => {
            thenStep.test(store);
        });
    }
}
export class BaseWhen {
    constructor(name, actioner) {
        this.name = name;
        this.actioner = actioner;
    }
    test(store) {
        console.log(" When:", this.name);
        return this.andWhen(store, this.actioner);
    }
}
;
export class BaseThen {
    constructor(name, callback) {
        this.name = name;
        this.callback = callback;
    }
    test(store) {
        console.log(" Then:", this.name);
        return this.callback(this.butThen(store));
    }
}
;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
export class TesterantoBasic {
    constructor(cc, suitesOverrides, givenOverides, whenOverides, thenOverides) {
        this.cc = cc;
        this.constructorator = cc;
        this.suitesOverrides = suitesOverrides;
        this.givenOverides = givenOverides;
        this.whenOverides = whenOverides;
        this.thenOverides = thenOverides;
    }
    Suites() {
        return this.suitesOverrides;
    }
    Given() {
        return this.givenOverides;
    }
    When() {
        return this.whenOverides;
    }
    Then() {
        return this.thenOverides;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
export class ClassySuite extends BaseSuite {
}
;
export class ClassyGiven extends BaseGiven {
    constructor(name, whens, thens, feature, thing) {
        super(name, whens, thens, feature);
        this.thing = thing;
    }
    givenThat() {
        return this.thing;
    }
}
export class ClassyWhen extends BaseWhen {
    andWhen(thing) {
        return this.actioner(thing);
    }
}
;
export class ClassyThen extends BaseThen {
    butThen(thing) {
        return thing;
    }
}
;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
export class TesterantoClassic {
    constructor(cc, givenOverides, whenOverides, thenOverides) {
        this.cc = cc;
        this.constructorator = cc;
        this.givenOverides = givenOverides;
        this.whenOverides = whenOverides;
        this.thenOverides = thenOverides;
    }
    Suites() {
        return {
            Default: (givenz) => new ClassySuite('Default constructor', this.constructorator.prototype, givenz),
        };
    }
    Given() {
        return Object.assign({ Default: (feature, whens, thens) => new ClassyGiven(`default constructor`, whens, thens, feature, new this.constructorator()) }, this.givenOverides);
    }
    When() {
        const objectdescription = Object.getOwnPropertyDescriptors(this.constructorator.prototype);
        let autogeneratedWhens = {};
        Object.keys(objectdescription).forEach((k, ndx) => {
            autogeneratedWhens[k] = (...xArgs) => new ClassyWhen(`!${k}`, (y) => {
                return y[k](...xArgs);
            });
        });
        /* @ts-ignore:next-line */
        return Object.assign(Object.assign({}, autogeneratedWhens), this.whenOverides);
    }
    Then() {
        const objectdescription = Object.getOwnPropertyDescriptors(this.constructorator.prototype);
        let autogeneratedWhens = {};
        Object.keys(objectdescription).forEach((k, ndx) => {
            autogeneratedWhens[k] = (...xArgs) => new ClassyWhen(`!${k}`, (y) => {
                return y[k](...xArgs);
            });
        });
        /* @ts-ignore:next-line */
        return Object.assign(Object.assign({}, autogeneratedWhens), this.thenOverides);
    }
}
export const TesterantoClassicFactory = (thing, givens, whens, thens) => {
    const makeClassGivens = (simpleGivens) => {
        return new ClassyGiven(`width of 1 and height of 1`, whens, thens, feature, new Rectangle(1, 1));
    };
    return new TesterantoClassic(thing, makeClassGivens(givens), 
    // {
    //   WidthOfOneAndHeightOfOne: (feature, whens, thens) =>
    //     new ClassyGiven(`width of 1 and height of 1`, whens, thens, feature, new Rectangle(1, 1)
    //     ),
    //   WidthAndHeightOf: (feature, whens, thens, width, height,) =>
    //     new ClassyGiven(`width of "${width} and height of "${height}"`, whens, thens, feature, new thing(height, width)),
    // },
    // as Record<keyof IGS, (feature: any, whens: any, thens: any) => ClassyGiven<any>>
    {
        HeightIsPubliclySetTo: (height) => new ClassyWhen(`the height is set to "${height}"`, (rectangle) => rectangle.height = height),
        WidthIsPubliclySetTo: (width) => new ClassyWhen(`the width is set to "${width}"`, (rectangle) => rectangle.width = width),
    }, {
        AreaPlusCircumference: (combined) => new ClassyThen(`the area+circumference is "${combined}"`, (rectangle) => assert.equal(rectangle.area() + rectangle.circumference(), combined)),
    });
};
